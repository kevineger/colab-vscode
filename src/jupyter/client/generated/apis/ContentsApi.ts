// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * Jupyter Server API
 * Server API
 *
 * The version of the OpenAPI document: 5
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Checkpoints,
  Contents,
  ContentsCreateRequest,
  ContentsGet400Response,
  ContentsRenameRequest,
  ContentsSaveRequest,
} from '../models/index';
import {
    CheckpointsFromJSON,
    CheckpointsToJSON,
    ContentsFromJSON,
    ContentsToJSON,
    ContentsCreateRequestFromJSON,
    ContentsCreateRequestToJSON,
    ContentsGet400ResponseFromJSON,
    ContentsGet400ResponseToJSON,
    ContentsRenameRequestFromJSON,
    ContentsRenameRequestToJSON,
    ContentsSaveRequestFromJSON,
    ContentsSaveRequestToJSON,
} from '../models/index';

export interface ContentsCreateOperationRequest {
    path: string;
    model?: ContentsCreateRequest;
}

export interface ContentsCreateCheckpointRequest {
    path: string;
}

export interface ContentsDeleteRequest {
    path: string;
}

export interface ContentsDeleteCheckpointRequest {
    path: string;
    checkpointId: string;
}

export interface ContentsGetRequest {
    path: string;
    type?: ContentsGetTypeEnum;
    format?: ContentsGetFormatEnum;
    content?: number;
    hash?: number;
}

export interface ContentsListCheckpointsRequest {
    path: string;
}

export interface ContentsRenameOperationRequest {
    path: string;
    rename: ContentsRenameRequest;
}

export interface ContentsRestoreCheckpointRequest {
    path: string;
    checkpointId: string;
}

export interface ContentsSaveOperationRequest {
    path: string;
    model?: ContentsSaveRequest;
}

/**
 * ContentsApi - interface
 * 
 * @export
 * @interface ContentsApiInterface
 */
export interface ContentsApiInterface {
    /**
     * A POST to /api/contents/path creates a New untitled, empty file or directory. A POST to /api/contents/path with body {\'copy_from\': \'/path/to/OtherNotebook.ipynb\'} creates a new copy of OtherNotebook in path.
     * @summary Create a new file in the specified path
     * @param {string} path file path
     * @param {ContentsCreateRequest} [model] Path of file to copy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentsApiInterface
     */
    createRaw(requestParameters: ContentsCreateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Contents>>;

    /**
     * A POST to /api/contents/path creates a New untitled, empty file or directory. A POST to /api/contents/path with body {\'copy_from\': \'/path/to/OtherNotebook.ipynb\'} creates a new copy of OtherNotebook in path.
     * Create a new file in the specified path
     */
    create(requestParameters: ContentsCreateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Contents>;

    /**
     * Create a new checkpoint with the current state of a file. With the default FileContentsManager, only one checkpoint is supported, so creating new checkpoints clobbers existing ones.
     * @summary Create a new checkpoint for a file
     * @param {string} path file path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentsApiInterface
     */
    createCheckpointRaw(requestParameters: ContentsCreateCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Checkpoints>>;

    /**
     * Create a new checkpoint with the current state of a file. With the default FileContentsManager, only one checkpoint is supported, so creating new checkpoints clobbers existing ones.
     * Create a new checkpoint for a file
     */
    createCheckpoint(requestParameters: ContentsCreateCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Checkpoints>;

    /**
     * 
     * @summary Delete a file in the given path
     * @param {string} path file path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentsApiInterface
     */
    deleteRaw(requestParameters: ContentsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete a file in the given path
     */
    delete(requestParameters: ContentsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * 
     * @summary Delete a checkpoint
     * @param {string} path file path
     * @param {string} checkpointId Checkpoint id for a file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentsApiInterface
     */
    deleteCheckpointRaw(requestParameters: ContentsDeleteCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete a checkpoint
     */
    deleteCheckpoint(requestParameters: ContentsDeleteCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * A client can optionally specify a type and/or format argument via URL parameter. When given, the Contents service shall return a model in the requested type and/or format. If the request cannot be satisfied, e.g. type=text is requested, but the file is binary, then the request shall fail with 400 and have a JSON response containing a \'reason\' field, with the value \'bad format\' or \'bad type\', depending on what was requested.
     * @summary Get contents of file or directory
     * @param {string} path file path
     * @param {'file' | 'directory'} [type] File type (\&#39;file\&#39;, \&#39;directory\&#39;)
     * @param {'text' | 'base64'} [format] How file content should be returned (\&#39;text\&#39;, \&#39;base64\&#39;)
     * @param {number} [content] Return content (0 for no content, 1 for return content)
     * @param {number} [hash] May return hash hexdigest string of content and the hash algorithm (0 for no hash - default, 1 for return hash). It may be ignored by the content manager.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentsApiInterface
     */
    getRaw(requestParameters: ContentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Contents>>;

    /**
     * A client can optionally specify a type and/or format argument via URL parameter. When given, the Contents service shall return a model in the requested type and/or format. If the request cannot be satisfied, e.g. type=text is requested, but the file is binary, then the request shall fail with 400 and have a JSON response containing a \'reason\' field, with the value \'bad format\' or \'bad type\', depending on what was requested.
     * Get contents of file or directory
     */
    get(requestParameters: ContentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Contents>;

    /**
     * List checkpoints for a given file. There will typically be zero or one results.
     * @summary Get a list of checkpoints for a file
     * @param {string} path file path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentsApiInterface
     */
    listCheckpointsRaw(requestParameters: ContentsListCheckpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Checkpoints>>>;

    /**
     * List checkpoints for a given file. There will typically be zero or one results.
     * Get a list of checkpoints for a file
     */
    listCheckpoints(requestParameters: ContentsListCheckpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Checkpoints>>;

    /**
     * 
     * @summary Rename a file or directory without re-uploading content
     * @param {string} path file path
     * @param {ContentsRenameRequest} rename New path for file or directory.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentsApiInterface
     */
    renameRaw(requestParameters: ContentsRenameOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Contents>>;

    /**
     * Rename a file or directory without re-uploading content
     */
    rename(requestParameters: ContentsRenameOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Contents>;

    /**
     * 
     * @summary Restore a file to a particular checkpointed state
     * @param {string} path file path
     * @param {string} checkpointId Checkpoint id for a file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentsApiInterface
     */
    restoreCheckpointRaw(requestParameters: ContentsRestoreCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Restore a file to a particular checkpointed state
     */
    restoreCheckpoint(requestParameters: ContentsRestoreCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Saves the file in the location specified by name and path.  PUT is very similar to POST, but the requester specifies the name, whereas with POST, the server picks the name.
     * @summary Save or upload file.
     * @param {string} path file path
     * @param {ContentsSaveRequest} [model] New path for file or directory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentsApiInterface
     */
    saveRaw(requestParameters: ContentsSaveOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Contents>>;

    /**
     * Saves the file in the location specified by name and path.  PUT is very similar to POST, but the requester specifies the name, whereas with POST, the server picks the name.
     * Save or upload file.
     */
    save(requestParameters: ContentsSaveOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Contents>;

}

/**
 * 
 */
export class ContentsApi extends runtime.BaseAPI implements ContentsApiInterface {

    /**
     * A POST to /api/contents/path creates a New untitled, empty file or directory. A POST to /api/contents/path with body {\'copy_from\': \'/path/to/OtherNotebook.ipynb\'} creates a new copy of OtherNotebook in path.
     * Create a new file in the specified path
     */
    async createRaw(requestParameters: ContentsCreateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Contents>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling create().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/contents/{path}`;
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ContentsCreateRequestToJSON(requestParameters['model']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContentsFromJSON(jsonValue));
    }

    /**
     * A POST to /api/contents/path creates a New untitled, empty file or directory. A POST to /api/contents/path with body {\'copy_from\': \'/path/to/OtherNotebook.ipynb\'} creates a new copy of OtherNotebook in path.
     * Create a new file in the specified path
     */
    async create(requestParameters: ContentsCreateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Contents> {
        const response = await this.createRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new checkpoint with the current state of a file. With the default FileContentsManager, only one checkpoint is supported, so creating new checkpoints clobbers existing ones.
     * Create a new checkpoint for a file
     */
    async createCheckpointRaw(requestParameters: ContentsCreateCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Checkpoints>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling createCheckpoint().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/contents/{path}/checkpoints`;
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CheckpointsFromJSON(jsonValue));
    }

    /**
     * Create a new checkpoint with the current state of a file. With the default FileContentsManager, only one checkpoint is supported, so creating new checkpoints clobbers existing ones.
     * Create a new checkpoint for a file
     */
    async createCheckpoint(requestParameters: ContentsCreateCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Checkpoints> {
        const response = await this.createCheckpointRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a file in the given path
     */
    async deleteRaw(requestParameters: ContentsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling delete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/contents/{path}`;
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a file in the given path
     */
    async delete(requestParameters: ContentsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a checkpoint
     */
    async deleteCheckpointRaw(requestParameters: ContentsDeleteCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling deleteCheckpoint().'
            );
        }

        if (requestParameters['checkpointId'] == null) {
            throw new runtime.RequiredError(
                'checkpointId',
                'Required parameter "checkpointId" was null or undefined when calling deleteCheckpoint().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/contents/{path}/checkpoints/{checkpoint_id}`;
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));
        urlPath = urlPath.replace(`{${"checkpoint_id"}}`, encodeURIComponent(String(requestParameters['checkpointId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a checkpoint
     */
    async deleteCheckpoint(requestParameters: ContentsDeleteCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCheckpointRaw(requestParameters, initOverrides);
    }

    /**
     * A client can optionally specify a type and/or format argument via URL parameter. When given, the Contents service shall return a model in the requested type and/or format. If the request cannot be satisfied, e.g. type=text is requested, but the file is binary, then the request shall fail with 400 and have a JSON response containing a \'reason\' field, with the value \'bad format\' or \'bad type\', depending on what was requested.
     * Get contents of file or directory
     */
    async getRaw(requestParameters: ContentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Contents>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling get().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['content'] != null) {
            queryParameters['content'] = requestParameters['content'];
        }

        if (requestParameters['hash'] != null) {
            queryParameters['hash'] = requestParameters['hash'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/contents/{path}`;
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContentsFromJSON(jsonValue));
    }

    /**
     * A client can optionally specify a type and/or format argument via URL parameter. When given, the Contents service shall return a model in the requested type and/or format. If the request cannot be satisfied, e.g. type=text is requested, but the file is binary, then the request shall fail with 400 and have a JSON response containing a \'reason\' field, with the value \'bad format\' or \'bad type\', depending on what was requested.
     * Get contents of file or directory
     */
    async get(requestParameters: ContentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Contents> {
        const response = await this.getRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List checkpoints for a given file. There will typically be zero or one results.
     * Get a list of checkpoints for a file
     */
    async listCheckpointsRaw(requestParameters: ContentsListCheckpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Checkpoints>>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling listCheckpoints().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/contents/{path}/checkpoints`;
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CheckpointsFromJSON));
    }

    /**
     * List checkpoints for a given file. There will typically be zero or one results.
     * Get a list of checkpoints for a file
     */
    async listCheckpoints(requestParameters: ContentsListCheckpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Checkpoints>> {
        const response = await this.listCheckpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Rename a file or directory without re-uploading content
     */
    async renameRaw(requestParameters: ContentsRenameOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Contents>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling rename().'
            );
        }

        if (requestParameters['rename'] == null) {
            throw new runtime.RequiredError(
                'rename',
                'Required parameter "rename" was null or undefined when calling rename().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/contents/{path}`;
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ContentsRenameRequestToJSON(requestParameters['rename']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContentsFromJSON(jsonValue));
    }

    /**
     * Rename a file or directory without re-uploading content
     */
    async rename(requestParameters: ContentsRenameOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Contents> {
        const response = await this.renameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restore a file to a particular checkpointed state
     */
    async restoreCheckpointRaw(requestParameters: ContentsRestoreCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling restoreCheckpoint().'
            );
        }

        if (requestParameters['checkpointId'] == null) {
            throw new runtime.RequiredError(
                'checkpointId',
                'Required parameter "checkpointId" was null or undefined when calling restoreCheckpoint().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/contents/{path}/checkpoints/{checkpoint_id}`;
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));
        urlPath = urlPath.replace(`{${"checkpoint_id"}}`, encodeURIComponent(String(requestParameters['checkpointId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Restore a file to a particular checkpointed state
     */
    async restoreCheckpoint(requestParameters: ContentsRestoreCheckpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.restoreCheckpointRaw(requestParameters, initOverrides);
    }

    /**
     * Saves the file in the location specified by name and path.  PUT is very similar to POST, but the requester specifies the name, whereas with POST, the server picks the name.
     * Save or upload file.
     */
    async saveRaw(requestParameters: ContentsSaveOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Contents>> {
        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling save().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/contents/{path}`;
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ContentsSaveRequestToJSON(requestParameters['model']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContentsFromJSON(jsonValue));
    }

    /**
     * Saves the file in the location specified by name and path.  PUT is very similar to POST, but the requester specifies the name, whereas with POST, the server picks the name.
     * Save or upload file.
     */
    async save(requestParameters: ContentsSaveOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Contents> {
        const response = await this.saveRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ContentsGetTypeEnum = {
    File: 'file',
    Directory: 'directory'
} as const;
export type ContentsGetTypeEnum = typeof ContentsGetTypeEnum[keyof typeof ContentsGetTypeEnum];
/**
 * @export
 */
export const ContentsGetFormatEnum = {
    Text: 'text',
    Base64: 'base64'
} as const;
export type ContentsGetFormatEnum = typeof ContentsGetFormatEnum[keyof typeof ContentsGetFormatEnum];
